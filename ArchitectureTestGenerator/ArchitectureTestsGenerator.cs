using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ArchitectureTestGenerator;

[Generator]
public class ArchitectureTestsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Get all project references and their properties
        var compilationProvider = context.CompilationProvider;

        context.RegisterSourceOutput(compilationProvider, (spc, compilation) =>
        {
            // Analyze the compilation to find all assemblies and modules
            var projectAnalyzer = new ProjectAnalyzer(compilation);
            var analysisResult = projectAnalyzer.Analyze();

            if (analysisResult.Modules.Count == 0 || analysisResult.AssemblyReferences.Count == 0)
            {
                // No modules found, generate a diagnostic comment
                var diagnostic = new StringBuilder();
                diagnostic.AppendLine("// <auto-generated/>");
                diagnostic.AppendLine("// No modular monolith projects found.");
                diagnostic.AppendLine("// The source generator looks for projects following the pattern: ModuleName.ProjectType");
                diagnostic.AppendLine("// Ensure your test project references the module projects you want to test.");
                diagnostic.AppendLine($"// Found {analysisResult.AssemblyReferences.Count} assembly references and {analysisResult.Modules.Count} modules.");
                spc.AddSource("WhenValidatingModuleBoundaries.g.cs", SourceText.From(diagnostic.ToString(), Encoding.UTF8));
                return;
            }

            // Generate the test class
            var sourceText = GenerateArchitectureTests(analysisResult);
            spc.AddSource("WhenValidatingModuleBoundaries.g.cs", SourceText.From(sourceText, Encoding.UTF8));
        });
    }

    private string GenerateArchitectureTests(AnalysisResult result)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using ArchUnitNET.Domain;");
        sb.AppendLine("using ArchUnitNET.Loader;");
        sb.AppendLine("using ArchUnitNET.xUnit;");
        sb.AppendLine("using Xunit;");
        sb.AppendLine("using static ArchUnitNET.Fluent.ArchRuleDefinition;");
        sb.AppendLine();
        sb.AppendLine("namespace ArchitectureTests;");
        sb.AppendLine();
        sb.AppendLine("public class WhenValidatingModuleBoundaries");
        sb.AppendLine("{");

        // Generate the Architecture field
        sb.AppendLine("    private static readonly Architecture Architecture = new ArchLoader()");
        sb.AppendLine("        .LoadAssemblies(");

        var assemblyReferences = result.AssemblyReferences.ToList();
        for (int i = 0; i < assemblyReferences.Count; i++)
        {
            var asm = assemblyReferences[i];
            var comma = i < assemblyReferences.Count - 1 ? "," : "";
            sb.AppendLine($"            typeof({asm.TypeReference}).Assembly{comma}");
        }

        sb.AppendLine("        )");
        sb.AppendLine("        .Build();");
        sb.AppendLine();

        // Generate the Modules array
        sb.Append("    private static readonly string[] Modules = { ");
        sb.Append(string.Join(", ", result.Modules.Select(m => $"\"{m}\"")));
        sb.AppendLine(" };");
        sb.AppendLine();

        // Generate all test methods
        GenerateIntraModuleTests(sb);
        GenerateInterModuleTests(sb);
        GenerateSharedDependencyTests(sb);
        GenerateApiProjectTests(sb);
        GenerateStructuralValidationTests(sb);

        sb.AppendLine("}");

        return sb.ToString();
    }

    private void GenerateIntraModuleTests(StringBuilder sb)
    {
        sb.AppendLine("    // Intra-Module Dependency Rules");
        sb.AppendLine();
        sb.AppendLine("    [Fact]");
        sb.AppendLine("    public void DomainModelProject_ShouldNotReference_AnyOtherProjectWithinSameModule()");
        sb.AppendLine("    {");
        sb.AppendLine("        foreach (var module in Modules)");
        sb.AppendLine("        {");
        sb.AppendLine("            var domainModelTypes = Types()");
        sb.AppendLine("                .That()");
        sb.AppendLine("                .ResideInNamespaceMatching($\"{module}.DomainModel.*\")");
        sb.AppendLine("                .As($\"{module}.DomainModel types\");");
        sb.AppendLine();
        sb.AppendLine("            var otherModuleProjects = Types()");
        sb.AppendLine("                .That()");
        sb.AppendLine("                .ResideInNamespaceMatching($\"{module}.*\")");
        sb.AppendLine("                .And()");
        sb.AppendLine("                .DoNotResideInNamespaceMatching($\"{module}.DomainModel.*\")");
        sb.AppendLine("                .As($\"Other {module} projects\");");
        sb.AppendLine();
        sb.AppendLine("            var rule = domainModelTypes");
        sb.AppendLine("                .Should()");
        sb.AppendLine("                .NotDependOnAny(otherModuleProjects)");
        sb.AppendLine("                .Because($\"DomainModel project should not reference any other project within {module} module\");");
        sb.AppendLine();
        sb.AppendLine("            rule.Check(Architecture);");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    [Fact]");
        sb.AppendLine("    public void ApplicationProject_CanReference_AnyOtherProjectWithinSameModule()");
        sb.AppendLine("    {");
        sb.AppendLine("        // This is a permissive rule - no restrictions to enforce");
        sb.AppendLine("        // Application projects are allowed to reference anything within their module");
        sb.AppendLine("        // This test documents the rule exists but doesn't need enforcement");
        sb.AppendLine("        Assert.True(true, \"Application projects are allowed to reference any other project within the same module\");");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    [Fact]");
        sb.AppendLine("    public void NonApplicationNonDomainModelProjects_ShouldOnlyReference_PublishedInterfacesOfOtherModules()");
        sb.AppendLine("    {");
        sb.AppendLine("        foreach (var sourceModule in Modules)");
        sb.AppendLine("        {");
        sb.AppendLine("            // Get all projects in the source module except Application and DomainModel");
        sb.AppendLine("            var nonApplicationDomainModelTypes = Types()");
        sb.AppendLine("                .That()");
        sb.AppendLine("                .ResideInNamespaceMatching($\"{sourceModule}.*\")");
        sb.AppendLine("                .And()");
        sb.AppendLine("                .DoNotResideInNamespaceMatching($\"{sourceModule}.Application.*\")");
        sb.AppendLine("                .And()");
        sb.AppendLine("                .DoNotResideInNamespaceMatching($\"{sourceModule}.DomainModel.*\")");
        sb.AppendLine("                .As($\"{sourceModule} non-Application non-DomainModel types\");");
        sb.AppendLine();
        sb.AppendLine("            // Build allowed dependencies");
        sb.AppendLine("            var allowedDependencies = Types()");
        sb.AppendLine("                .That()");
        sb.AppendLine("                .ResideInNamespaceMatching($\"{sourceModule}.*\") // Own module");
        sb.AppendLine("                .Or()");
        sb.AppendLine("                .ResideInNamespaceMatching(\"SharedInfrastructure.*\") // Shared project");
        sb.AppendLine("                .Or()");
        sb.AppendLine("                .ResideInAssemblyMatching(\"System.*\")");
        sb.AppendLine("                .Or()");
        sb.AppendLine("                .ResideInAssemblyMatching(\"Microsoft.*\");");
        sb.AppendLine();
        sb.AppendLine("            // Add PublishedInterfaces from other modules");
        sb.AppendLine("            foreach (var targetModule in Modules)");
        sb.AppendLine("            {");
        sb.AppendLine("                if (targetModule != sourceModule)");
        sb.AppendLine("                {");
        sb.AppendLine("                    allowedDependencies = allowedDependencies");
        sb.AppendLine("                        .Or()");
        sb.AppendLine("                        .ResideInNamespaceMatching($\"{targetModule}.PublishedInterfaces.*\");");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            var allowedDependenciesWithRule = allowedDependencies.As(\"Allowed dependencies\");");
        sb.AppendLine();
        sb.AppendLine("            var rule = nonApplicationDomainModelTypes");
        sb.AppendLine("                .Should()");
        sb.AppendLine("                .OnlyDependOn(allowedDependenciesWithRule)");
        sb.AppendLine("                .Because($\"Non-Application/DomainModel projects in {sourceModule} should only reference PublishedInterfaces, DomainModel of own module, and Shared project\");");
        sb.AppendLine();
        sb.AppendLine("            rule.Check(Architecture);");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private void GenerateInterModuleTests(StringBuilder sb)
    {
        sb.AppendLine("    // Inter-Module Dependency Rules");
        sb.AppendLine();
        sb.AppendLine("    [Fact]");
        sb.AppendLine("    public void ModuleProjects_MustOnlyReference_PublishedInterfacesOfOtherModules()");
        sb.AppendLine("    {");
        sb.AppendLine("        foreach (var sourceModule in Modules)");
        sb.AppendLine("        {");
        sb.AppendLine("            var sourceModuleTypes = Types()");
        sb.AppendLine("                .That()");
        sb.AppendLine("                .ResideInNamespaceMatching($\"{sourceModule}.*\")");
        sb.AppendLine("                .As($\"{sourceModule} module types\");");
        sb.AppendLine();
        sb.AppendLine("            // Build disallowed dependencies for other modules (non-PublishedInterfaces)");
        sb.AppendLine("            var disallowedDependencies = new List<IType>();");
        sb.AppendLine();
        sb.AppendLine("            foreach (var targetModule in Modules)");
        sb.AppendLine("            {");
        sb.AppendLine("                if (targetModule != sourceModule)");
        sb.AppendLine("                {");
        sb.AppendLine("                    var moduleTypes = Types()");
        sb.AppendLine("                        .That()");
        sb.AppendLine("                        .ResideInNamespaceMatching($\"{targetModule}.*\")");
        sb.AppendLine("                        .And()");
        sb.AppendLine("                        .DoNotResideInNamespaceMatching($\"{targetModule}.PublishedInterfaces.*\");");
        sb.AppendLine();
        sb.AppendLine("                    var types = moduleTypes.GetObjects(Architecture);");
        sb.AppendLine("                    disallowedDependencies.AddRange(types);");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            var rule = sourceModuleTypes");
        sb.AppendLine("                .Should()");
        sb.AppendLine("                .NotDependOnAny(disallowedDependencies)");
        sb.AppendLine("                .Because($\"{sourceModule} module should only reference PublishedInterfaces of other modules\");");
        sb.AppendLine();
        sb.AppendLine("            rule.Check(Architecture);");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    [Fact]");
        sb.AppendLine("    public void PublishedInterfacesProject_MustNotReference_PublishedInterfacesOfAnotherModule()");
        sb.AppendLine("    {");
        sb.AppendLine("        foreach (var sourceModule in Modules)");
        sb.AppendLine("        {");
        sb.AppendLine("            var sourcePublishedInterfacesTypes = Types()");
        sb.AppendLine("                .That()");
        sb.AppendLine("                .ResideInNamespaceMatching($\"{sourceModule}.PublishedInterfaces.*\")");
        sb.AppendLine("                .As($\"{sourceModule}.PublishedInterfaces types\");");
        sb.AppendLine("            ");
        sb.AppendLine("            var anyPublishedInterfacesFound = sourcePublishedInterfacesTypes.GetObjects(Architecture).Any();");
        sb.AppendLine();
        sb.AppendLine("            if (anyPublishedInterfacesFound)");
        sb.AppendLine("            {");
        sb.AppendLine("                // Build list of PublishedInterfaces from other modules");
        sb.AppendLine("                var otherPublishedInterfacesTypes = new List<IType>();");
        sb.AppendLine();
        sb.AppendLine("                foreach (var targetModule in Modules)");
        sb.AppendLine("                {");
        sb.AppendLine("                    if (targetModule != sourceModule)");
        sb.AppendLine("                    {");
        sb.AppendLine("                        var modulePublishedInterfaces = Types()");
        sb.AppendLine("                            .That()");
        sb.AppendLine("                            .ResideInNamespaceMatching($\"{targetModule}.PublishedInterfaces.*\");");
        sb.AppendLine();
        sb.AppendLine("                        var types = modulePublishedInterfaces.GetObjects(Architecture).ToList();");
        sb.AppendLine("                    ");
        sb.AppendLine("                        if (types.Any())");
        sb.AppendLine("                            otherPublishedInterfacesTypes.AddRange(types);");
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
        sb.AppendLine("                ");
        sb.AppendLine("                var rule = sourcePublishedInterfacesTypes");
        sb.AppendLine("                    .Should()");
        sb.AppendLine("                    .NotDependOnAny(otherPublishedInterfacesTypes)");
        sb.AppendLine("                    .Because($\"{sourceModule}.PublishedInterfaces should not reference PublishedInterfaces of other modules\");");
        sb.AppendLine();
        sb.AppendLine("                rule.Check(Architecture);");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private void GenerateSharedDependencyTests(StringBuilder sb)
    {
        sb.AppendLine("    // Shared Dependency Rules");
        sb.AppendLine();
        sb.AppendLine("    [Fact]");
        sb.AppendLine("    public void Modules_CanReference_SharedProject()");
        sb.AppendLine("    {");
        sb.AppendLine("        // This is a permissive rule - modules are allowed to reference Shared");
        sb.AppendLine("        // We verify that the Shared project exists and can be referenced");
        sb.AppendLine("        var sharedProjectExists = Architecture.Types");
        sb.AppendLine("            .Any(t => t.Namespace?.FullName?.StartsWith(\"SharedInfrastructure\") ?? false);");
        sb.AppendLine();
        sb.AppendLine("        Assert.True(sharedProjectExists, \"Shared project should exist and be available for modules to reference\");");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private void GenerateApiProjectTests(StringBuilder sb)
    {
        sb.AppendLine("    // Special Rules for API Projects");
        sb.AppendLine();
        sb.AppendLine("    [Fact]");
        sb.AppendLine("    public void ApiProject_CanReference_AnyProjectInAnyModule()");
        sb.AppendLine("    {");
        sb.AppendLine("        // API projects represent the composition root");
        sb.AppendLine("        // This is a permissive rule - no restrictions to enforce");
        sb.AppendLine("        // This test documents the rule exists but doesn't need enforcement");
        sb.AppendLine("        Assert.True(true, \"API projects are allowed to reference any project in any module\");");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private void GenerateStructuralValidationTests(StringBuilder sb)
    {
        sb.AppendLine("    // Additional structural validation");
        sb.AppendLine();
        sb.AppendLine("    [Fact]");
        sb.AppendLine("    public void EachModule_MustHave_ApplicationAndDomainModelProjects()");
        sb.AppendLine("    {");
        sb.AppendLine("        foreach (var module in Modules)");
        sb.AppendLine("        {");
        sb.AppendLine("            var hasApplication = Architecture.Types");
        sb.AppendLine("                .Any(t => t.Namespace?.FullName?.StartsWith($\"{module}.Application\") ?? false);");
        sb.AppendLine();
        sb.AppendLine("            var hasDomainModel = Architecture.Types");
        sb.AppendLine("                .Any(t => t.Namespace?.FullName?.StartsWith($\"{module}.DomainModel\") ?? false);");
        sb.AppendLine();
        sb.AppendLine("            Assert.True(hasApplication, $\"{module} module must have an Application project\");");
        sb.AppendLine("            Assert.True(hasDomainModel, $\"{module} module must have a DomainModel project\");");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    [Fact]");
        sb.AppendLine("    public void AllModuleProjects_MustStartWith_ModuleName()");
        sb.AppendLine("    {");
        sb.AppendLine();
        sb.AppendLine("        foreach (var module in Modules)");
        sb.AppendLine("        {");
        sb.AppendLine("            var moduleTypes = Architecture.Types");
        sb.AppendLine("                .Where(t => t.Namespace?.FullName?.StartsWith($\"{module}.\") ?? false);");
        sb.AppendLine();
        sb.AppendLine("            foreach (var type in moduleTypes)");
        sb.AppendLine("            {");
        sb.AppendLine("                Assert.True(");
        sb.AppendLine("                    type.Namespace?.FullName?.StartsWith($\"{module}.\") ?? false,");
        sb.AppendLine("                    $\"Type {type.FullName} should be in namespace starting with {module}.\");");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
    }
}

public class AnalysisResult
{
    public List<string> Modules { get; set; } = new();
    public List<AssemblyReference> AssemblyReferences { get; set; } = new();
}

public class AssemblyReference
{
    public string TypeReference { get; set; } = "";
    public string AssemblyName { get; set; } = "";
}

public class ProjectAnalyzer
{
    private readonly Compilation _compilation;

    public ProjectAnalyzer(Compilation compilation)
    {
        _compilation = compilation;
    }

    public AnalysisResult Analyze()
    {
        var result = new AnalysisResult();
        var moduleSet = new HashSet<string>();
        var assemblyRefs = new List<AssemblyReference>();

        // Look through all referenced assemblies - only project references
        foreach (var reference in _compilation.References)
        {
            if (_compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol assemblySymbol)
            {
                // Only include assemblies that are project references (not NuGet packages)
                // Project references have locations that point to actual DLL files in the solution
                var isProjectReference = reference is Microsoft.CodeAnalysis.CompilationReference portableRef;

                if (!isProjectReference)
                {
                    continue;
                }

                var assemblyName = assemblySymbol.Name;

                // Skip system assemblies only
                if (assemblyName.StartsWith("System") ||
                    assemblyName.StartsWith("Microsoft") ||
                    assemblyName.StartsWith("netstandard"))
                {
                    continue;
                }

                // Check if this follows the module pattern (e.g., "ModuleName.ProjectType")
                var parts = assemblyName.Split('.');
                if (parts.Length >= 2)
                {
                    var moduleName = parts[0];
                    var projectType = parts[1];

                    // Look for a public type in this assembly to use as typeof() reference
                    var publicType = GetPublicTypeFromAssembly(assemblySymbol);
                    if (publicType != null)
                    {
                        moduleSet.Add(moduleName);
                        assemblyRefs.Add(new AssemblyReference
                        {
                            TypeReference = publicType,
                            AssemblyName = assemblyName
                        });
                    }
                }
                else if (assemblyName == "SharedInfrastructure")
                {
                    // Handle SharedInfrastructure specially
                    var publicType = GetPublicTypeFromAssembly(assemblySymbol);
                    if (publicType != null)
                    {
                        assemblyRefs.Add(new AssemblyReference
                        {
                            TypeReference = publicType,
                            AssemblyName = assemblyName
                        });
                    }
                }
            }
        }

        result.Modules = moduleSet.OrderBy(m => m).ToList();
        result.AssemblyReferences = assemblyRefs.OrderBy(a => a.AssemblyName).ToList();

        return result;
    }

    private string? GetPublicTypeFromAssembly(IAssemblySymbol assemblySymbol)
    {
        // Try to find a public type in the global namespace or first namespace
        var types = GetAllTypes(assemblySymbol.GlobalNamespace);

        foreach (var type in types)
        {
            if (type.DeclaredAccessibility == Accessibility.Public && !type.IsAbstract)
            {
                return type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted));
            }
        }

        return null;
    }

    private IEnumerable<INamedTypeSymbol> GetAllTypes(INamespaceSymbol namespaceSymbol)
    {
        foreach (var type in namespaceSymbol.GetTypeMembers())
        {
            yield return type;
        }

        foreach (var childNamespace in namespaceSymbol.GetNamespaceMembers())
        {
            foreach (var type in GetAllTypes(childNamespace))
            {
                yield return type;
            }
        }
    }
}
